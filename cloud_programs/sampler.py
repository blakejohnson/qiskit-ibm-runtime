import numpy as np
import mthree
from qiskit import transpile
from qiskit.result import marginal_counts
from qiskit.exceptions import QiskitError

from qiskit.transpiler import PassManager, InstructionDurations
from qiskit.transpiler.passes import ALAPSchedule, DynamicalDecoupling
from qiskit.circuit.library import XGate, RZGate


DEFAULT_TRANSPILE_CONFIG = {'optimization_level': 3}

DEFAULT_RUN_CONFIG = {'shots': 4000}


def main(backend, user_messenger,
         circuits,
         transpile_config=None,
         run_config=None,
         skip_transpilation=False,
         use_dynamical_decoupling=False,
         use_measurement_mitigation=False,
         return_mitigation_overhead=False
        ):
    
    """Sample distributions generated by given circuits executed on the target backend.
    
    Parameters:
        backend (ProgramBackend): Qiskit backend instance.
        user_messenger (UserMessenger): Used to communicate with the program user.
        circuits: (QuantumCircuit or list): A single list of QuantumCircuits.
        transpile_config (dict): A collection of kwargs passed to transpile().
        run_config (dict): A collection of kwargs passed to backend.run().
        skip_transpilation (bool): Skip transpiling of circuits, default=False.
        use_dynamical_decoupling (bool): Insert dynamical decoupling sequences for
                                         improving fidelity. Requires targeting
                                         a real quantum backend, default=False.
        use_measurement_mitigation (bool): Improve resulting using measurement
                                           error mitigation, default=False.
        return_mitigation_overhead (bool): Return mitigation overhead factor,
                                           default=False.
                                           
    Notes:
        Here we convert to hex for the bitstrings like other routines do in Qiskit.
        To recover the original size of the classical register one needs to know
        the number of classical bits in the input circuits and pad appropriately.
                                           
    Returns:
        dict: A dictionary with counts, quasiprobabilities, and mitigation_overhead keys.
    """
    # Setup configurations
    if transpile_config is None:
        transpile_config = DEFAULT_TRANSPILE_CONFIG
    else:
        for key, val in DEFAULT_TRANSPILE_CONFIG.items():
            if key not in transpile_config:
                transpile_config[key] = val
        
    if run_config is None:
        run_config = DEFAULT_RUN_CONFIG
    else:
        for key, val in DEFAULT_RUN_CONFIG.items():
            if key not in run_config:
                run_config[key] = val


    # transpiling the circuits using given transpile options
    if not skip_transpilation:
        trans_circuits = transpile(circuits, backend=backend,
                                   **transpile_config)

        # Make sure everything is a list
        if not isinstance(trans_circuits, list):
            trans_circuits = [trans_circuits]
    # If skipping set circuits -> trans_circuits
    else:
        if not isinstance(circuits, list):
            trans_circuits = [circuits]
        else:
            trans_circuits = circuits
            
    # Do basic XpXm dynamical decoupling following the receipe in
    # arXiv:2108.09197, arXiv:2008.08571
    if use_dynamical_decoupling:
        if backend.configuration().simulator:
            raise SamplerError('Cannot use dynamical decoupling with a simulator.')
        durations = InstructionDurations.from_backend(backend)
        dd_sequence = [XGate(), XGate()]
        pm = PassManager([ALAPSchedule(durations),
                          DynamicalDecoupling(durations, dd_sequence)])
        # Run DD passmanager over circuits
        trans_circuits = pm.run(trans_circuits)
        if not isinstance(trans_circuits, list):
            trans_circuits = [trans_circuits]

    # If doing measurement mitigation we must build and calibrate a
    # mitigator object.  Will also determine which qubits need to be
    # calibrated.
    quasi_dists = []
    if use_measurement_mitigation:
        # Get an the measurement mappings at end of circuits
        meas_maps = mthree.utils.final_measurement_mapping(trans_circuits)
        # Get an M3 mitigator
        mit = mthree.M3Mitigation(backend)
        # Calibrate over the set of qubits measured in the transpiled circuits.
        mit.cals_from_system(meas_maps, shots=min(10000, backend.configuration().max_shots))

    # Compute raw results
    result = backend.run(trans_circuits, **run_config).result()
    raw_counts = result.get_counts()
    if not isinstance(raw_counts, list):
        raw_counts = [raw_counts]

    # Do the measurement mitigation
    mitigation_overhead = []
    if use_measurement_mitigation:
        qubit_lists = []
        temp_counts = []
        # We need to do a loop and check to see if the
        # user passed circuits with more classical bits than
        # final measured bits.
        for idx, circ in enumerate(trans_circuits):
            num_cbits = circ.num_clbits
            num_measured_bits = len(meas_maps[idx])
            _counts = raw_counts[idx]
            # check if more bits than measured so need to marginalize
            if num_cbits > num_measured_bits:
                temp_counts.append(marginal_counts(_counts,
                                                   list(meas_maps[idx].values())))
            else:
                temp_counts.append(_counts)
            qubit_lists.append(list(meas_maps[idx].keys()))
        
        quasi_dists = mit.apply_correction(temp_counts, qubit_lists,
                                           return_mitigation_overhead=return_mitigation_overhead)
        if return_mitigation_overhead:
            if not isinstance(quasi_dists, mthree.classes.QuasiCollection):
                mitigation_overhead = [quasi_dists.mitigation_overhead]
            else:
                mitigation_overhead = list(quasi_dists.mitigation_overhead)
                
        if not isinstance(quasi_dists, mthree.classes.QuasiCollection):
            quasi_dists = [quasi_dists]

    out = {'counts':[rc.hex_outcomes() for rc in raw_counts],
           'quasiprobabilities': [to_hex(qp) for qp in quasi_dists],
           'mitigation_overhead': mitigation_overhead}
    
    return out


class SamplerError(QiskitError):
    pass


def to_hex(qp):
    """Converts a dict with bitstrings to hex

    Parameters:
        qp (QuasiDistribution): Input quasi dict

    Returns:
        dict: hex dict.
    """
    hex_out = {}
    for key, val in qp.items():
        hex_out[hex(int(key, 2))] = val     
    return hex_out 
