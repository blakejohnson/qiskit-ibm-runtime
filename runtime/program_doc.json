[
  { "name": "quantum-kernel-alignment",
    "description": "Quantum kernel alignment algorithm that learns, on a given dataset, a quantum kernel maximizing the SVM classification margin.",
    "id": "quantum-kernel-alignment",
    "parameters": [
      {"name": "feature_map", "description": "An instance of FeatureMap in dictionary format used to map classical data into a quantum state space.", "type": "dict", "required": true},
      {"name": "data", "description": "NxD array of training data, where N is the number of samples and D is the feature dimension.", "type": "numpy.ndarray", "required": true},
      {"name": "labels", "description": "Nx1 array of +/-1 labels of the N training samples.", "type": "numpy.ndarray", "required": true},
      {"name": "initial_kernel_parameters", "description": "Initial parameters of the quantum kernel. If not specified, an array of randomly generated numbers is used.", "type": "numpy.ndarray", "required": false},
      {"name": "maxiters", "description": "Number of SPSA optimization steps. Default is 10.", "type": "int", "required": false},
      {"name": "C", "description": "Penalty parameter for the soft-margin support vector machine. Default is 1.", "type": "float", "required": false},
      {"name": "initial_layout", "description": "Initial position of virtual qubits on the physical qubits of the quantum device. Default is None.", "type": "list or dict", "required": false}
    ],
    "return_values": [
      {"name": "aligned_kernel_parameters", "description": "The optimized kernel parameters found from quantum kernel alignment.", "type": "numpy.ndarray"},
      {"name": "aligned_kernel_matrix", "description": "The aligned quantum kernel matrix evaluated with the optimized kernel parameters on the training data.", "type": "numpy.ndarray"}
    ]
  },
  { "name": "Circuit-Runner",
    "description": "A runtime program that takes one or more circuits, compiles them, executes them on the selected backend, and returns the results.",
    "id": "Circuit-Runner",
    "parameters": [
      {"name": "circuits", "description": "A circuit or a list of circuits to compile and execute.", "type": "A QuantumCircuit or a list of QuantumCircuits.", "required": true},
      {"name": "initial_layout", "description": "Initial position of virtual qubits on physical qubits.", "type": "dict or list", "required": false},
      {"name": "layout_method", "description": "Name of layout selection pass ('trivial', 'dense', 'noise_adaptive', 'sabre')", "type": "string", "required": false},
      {"name": "routing_method", "description": "Name of routing pass ('basic', 'lookahead', 'stochastic', 'sabre').", "type": "string", "required": false},
      {"name": "translation_method", "description": "Name of translation pass ('unroller', 'translator', 'synthesis').", "type": "string", "required": false},
      {"name": "scheduling_method", "description": "Name of scheduling pass ('as_soon_as_possible', 'as_late_as_possible').", "type": "string", "required": false},
      {"name": "instruction_durations", "description": "Durations of instructions.", "type": "A list of tuples: [(instruction_name, qubits, duration, unit), ...].", "required": false},
      {"name": "dt", "description": "Backend sample time (resolution) in seconds.", "type": "float", "required": false},
      {"name": "seed_transpiler", "description": "Sets random seed for the stochastic parts of the transpiler.", "type": "int", "required": false},
      {"name": "optimization_level", "description": "How much optimization to perform on the circuits (0-3). Higher levels generate more optimized circuits. Default is 1.", "type": "int", "required": false}
    ],
    "return_values": [
      {"name": "results", "description": "Circuit execution results.", "type": "qiskit.result.Result object"}
    ]
  },
  { "name": "VQE",
    "description": "A runtime program that takes a Hamiltonian as an input and return the optimization.",
    "id": "VQE",
    "parameters": [
      {"name": "observable", "description": "N-qubit operator in a Pauli basis representation.", "type": "PauliSumOp.", "required": true},
      {"name": "circuit", "description": "The variational circuit whose parameters to optimize.", "type": "QuantumCircuit", "required": true},
      {"name": "optimizer", "description": "Classical optimizer to be used (\"SPSA\", or \"QN-SPSA\").", "type": "string", "required": true},
      {"name": "optimizer_params", "description": "Parameters required by the optimizer (e.g. learning rates, initial points, number of iterations, etc.).", "type": "dict", "required": false},
      {"name": "initial_point", "description": "Initial point. A numpy array or \"random\".", "type": "numpy.ndarray", "required": false},
      {"name": "readout_error_mitigation", "description": "Whether readout error mitigation is to be applied. Default is False.", "type": "boolean", "required": false}
    ],
    "return_values": [
      {"name": "n/a", "description": "Minimum eigensolver result.", "type": "MinimumEigensolverResult"}
    ]
  }
]
